<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>QuantileDigest.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jcommon stats package</a> &gt; <a href="index.html" class="el_package">com.facebook.stats</a> &gt; <span class="el_source">QuantileDigest.java</span></div><h1>QuantileDigest.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.facebook.stats;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterators;
import com.google.common.collect.Ordering;
import com.google.common.collect.PeekingIterator;
import com.google.common.util.concurrent.AtomicDouble;

import javax.annotation.concurrent.ThreadSafe;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static java.lang.String.format;

/**
 * &lt;p&gt;&lt;/p&gt;Implements http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.132.7343, a data
 * structure for approximating quantiles by trading off error with memory requirements.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;/p&gt;The size of the digest is adjusted dynamically to achieve the error bound and requires
 * O(log2(U) / maxError) space, where &lt;em&gt;U&lt;/em&gt; is the number of bits needed to represent the
 * domain of the values added to the digest.&lt;/p&gt;
 *
 * &lt;p&gt;The error is defined as the discrepancy between the real rank of the value returned in a
 * quantile query and the rank corresponding to the queried quantile.&lt;/p&gt;
 *
 * &lt;p&gt;Thus, for a query for quantile &lt;em&gt;q&lt;/em&gt; that returns value &lt;em&gt;v&lt;/em&gt;, the error is
 * |rank(v) - q * N| / N, where N is the number of elements added to the digest and rank(v) is the
 * real rank of &lt;em&gt;v&lt;/em&gt;&lt;/p&gt;
 *
 * &lt;p&gt;This class also supports exponential decay. The implementation is based on the ideas laid out
 * in http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.159.3978&lt;/p&gt;
 */
@ThreadSafe
public class QuantileDigest {
  private static final int MAX_BITS = 64;
  private static final double MAX_SIZE_FACTOR = 1.5;

  // needs to be such that Math.exp(alpha * seconds) does not grow too big
  static final long RESCALE_THRESHOLD_SECONDS = 50;
  static final double ZERO_WEIGHT_THRESHOLD = 1e-5;

  private final double maxError;
  private final Clock clock;
  private final double alpha;
  private final boolean compressAutomatically;

  private Node root;

  private double weightedCount;
  private long max;
<span class="fc" id="L73">  private long min = Long.MAX_VALUE;</span>

  private long landmarkInSeconds;

<span class="fc" id="L77">  private int totalNodeCount = 0;</span>
<span class="fc" id="L78">  private int nonZeroNodeCount = 0;</span>
<span class="fc" id="L79">  private int compressions = 0;</span>
<span class="fc" id="L80">  private int maxTotalNodeCount = 0;</span>
<span class="fc" id="L81">  private int maxTotalNodesAfterCompress = 0;</span>

<span class="pc" id="L83">  private enum TraversalOrder {</span>
<span class="fc" id="L84">    FORWARD, REVERSE</span>
  }

  /**
   * &lt;p&gt;Create a QuantileDigest with a maximum error guarantee of &quot;maxError&quot; and no decay.
   *
   * @param maxError the max error tolerance
   */
  public QuantileDigest(double maxError) {
<span class="fc" id="L93">    this(maxError, 0);</span>
<span class="fc" id="L94">  }</span>

  /**
   *&lt;p&gt;Create a QuantileDigest with a maximum error guarantee of &quot;maxError&quot; and exponential decay
   * with factor &quot;alpha&quot;.&lt;/p&gt;
   *
   * @param maxError the max error tolerance
   * @param alpha the exponential decay factor (0.0 =&gt; no decay)
   */
  public QuantileDigest(double maxError, double alpha) {
<span class="fc" id="L104">    this(maxError, alpha, new RealtimeClock(), true);</span>
<span class="fc" id="L105">  }</span>

  @VisibleForTesting
<span class="fc" id="L108">  QuantileDigest(double maxError, double alpha, Clock clock, boolean compressAutomatically) {</span>
<span class="pc bpc" id="L109" title="2 of 4 branches missed.">    checkArgument(maxError &gt;= 0 &amp;&amp; maxError &lt;= 1, &quot;maxError must be in range [0, 1]&quot;);</span>
<span class="pc bpc" id="L110" title="2 of 4 branches missed.">    checkArgument(alpha &gt;= 0 &amp;&amp; alpha &lt; 1, &quot;alpha must be in range [0, 1)&quot;);</span>

<span class="fc" id="L112">    this.maxError = maxError;</span>
<span class="fc" id="L113">    this.alpha = alpha;</span>
<span class="fc" id="L114">    this.clock = clock;</span>
<span class="fc" id="L115">    this.compressAutomatically = compressAutomatically;</span>

<span class="fc" id="L117">    landmarkInSeconds = TimeUnit.MILLISECONDS.toSeconds(clock.getMillis());</span>
<span class="fc" id="L118">  }</span>

  /**
   * Adds a value to this digest. The value must be &gt;= 0
   *
   * @param value
   */
  public synchronized void add(long value) {
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">    checkArgument(value &gt;= 0, &quot;value must be &gt;= 0&quot;);</span>

<span class="fc" id="L128">    long nowInSeconds = TimeUnit.MILLISECONDS.toSeconds(clock.getMillis());</span>

<span class="fc" id="L130">    int maxExpectedNodeCount = 3 * calculateCompressionFactor();</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">    if (nowInSeconds - landmarkInSeconds &gt;= RESCALE_THRESHOLD_SECONDS) {</span>
<span class="fc" id="L132">      rescale(nowInSeconds);</span>
<span class="fc" id="L133">      compress(); // need to compress to get rid of nodes that may have decayed to ~ 0</span>
    }
<span class="pc bpc" id="L135" title="1 of 4 branches missed.">    else if (nonZeroNodeCount &gt; MAX_SIZE_FACTOR * maxExpectedNodeCount &amp;&amp; compressAutomatically) {</span>
      // The size (number of non-zero nodes) of the digest is at most 3 * compression factor
      // If we're over MAX_SIZE_FACTOR of the expected size, compress
      // Note: we don't compress as soon as we go over expectedNodeCount to avoid unnecessarily
      // running a compression for every new added element when we're close to boundary
<span class="fc" id="L140">      compress();</span>
    }

<span class="fc" id="L143">    double weight = weight(TimeUnit.MILLISECONDS.toSeconds(clock.getMillis()));</span>
<span class="fc" id="L144">    weightedCount += weight;</span>

<span class="fc" id="L146">    max = Math.max(max, value);</span>
<span class="fc" id="L147">    min = Math.min(min, value);</span>
<span class="fc" id="L148">    insert(value, weight);</span>
<span class="fc" id="L149">  }</span>

  /**
   * Gets the values at the specified quantiles +/- maxError. The list of quantiles must be sorted
   * in increasing order, and each value must be in the range [0, 1]
   */
  public synchronized List&lt;Long&gt; getQuantiles(List&lt;Double&gt; quantiles) {
<span class="fc" id="L156">    checkArgument(Ordering.natural().isOrdered(quantiles),</span>
                  &quot;quantiles must be sorted in increasing order&quot;);
<span class="fc bfc" id="L158" title="All 2 branches covered.">    for (double quantile : quantiles) {</span>
<span class="pc bpc" id="L159" title="2 of 4 branches missed.">      checkArgument(quantile &gt;= 0 &amp;&amp; quantile &lt;= 1, &quot;quantile must be between [0,1]&quot;);</span>
<span class="fc" id="L160">    }</span>

<span class="fc" id="L162">    final ImmutableList.Builder&lt;Long&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L163">    final PeekingIterator&lt;Double&gt; iterator = Iterators.peekingIterator(quantiles.iterator());</span>

<span class="fc" id="L165">    postOrderTraversal(root, new Callback() {</span>
<span class="fc" id="L166">      private double sum = 0;</span>

      public boolean process(Node node) {
<span class="fc" id="L169">        sum += node.weightedCount;</span>

<span class="fc bfc" id="L171" title="All 4 branches covered.">        while (iterator.hasNext() &amp;&amp; sum &gt; iterator.peek() * weightedCount) {</span>
<span class="fc" id="L172">          iterator.next();</span>

          // we know the max value ever seen, so cap the percentile to provide better error
          // bounds in this case
<span class="fc" id="L176">          long value = Math.min(node.getUpperBound(), max);</span>

<span class="fc" id="L178">          builder.add(value);</span>
<span class="fc" id="L179">        }</span>

<span class="fc" id="L181">        return iterator.hasNext();</span>
      }
    });

    // we finished the traversal without consuming all quantiles. This means the remaining quantiles
    // correspond to the max known value
<span class="fc bfc" id="L187" title="All 2 branches covered.">    while (iterator.hasNext()) {</span>
<span class="fc" id="L188">      builder.add(max);</span>
<span class="fc" id="L189">      iterator.next();</span>
    }

<span class="fc" id="L192">    return builder.build();</span>
  }

  /**
   * Gets the value at the specified quantile +/- maxError. The quantile must be in the range [0, 1]
   */
  public synchronized long getQuantile(double quantile) {
<span class="fc" id="L199">    return getQuantiles(ImmutableList.of(quantile)).get(0);</span>
  }

  /**
   * Number (decayed) of elements added to this quantile digest
   */
  public synchronized double getCount() {
<span class="fc" id="L206">    return weightedCount / weight(TimeUnit.MILLISECONDS.toSeconds(clock.getMillis()));</span>
  }

  /*
   * Get the exponentially-decayed approximate counts of values in multiple buckets. The elements in
   * the provided list denote the upper bound each of the buckets and must be sorted in ascending
   * order.
   *
   * The approximate count in each bucket is guaranteed to be within 2 * totalCount * maxError of
   * the real count.
   */
  public synchronized List&lt;Bucket&gt; getHistogram(List&lt;Long&gt; bucketUpperBounds) {
<span class="fc" id="L218">    checkArgument(</span>
      Ordering.natural().isOrdered(bucketUpperBounds),
      &quot;buckets must be sorted in increasing order&quot;
    );

<span class="fc" id="L223">    final ImmutableList.Builder&lt;Bucket&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L224">    final PeekingIterator&lt;Long&gt; iterator = Iterators.peekingIterator(bucketUpperBounds.iterator());</span>

<span class="fc" id="L226">    final AtomicDouble sum = new AtomicDouble();</span>
<span class="fc" id="L227">    final AtomicDouble lastSum = new AtomicDouble();</span>

    // for computing weighed average of values in bucket
<span class="fc" id="L230">    final AtomicDouble bucketWeightedSum = new AtomicDouble();</span>

<span class="fc" id="L232">    final double normalizationFactor = weight(TimeUnit.MILLISECONDS.toSeconds(clock.getMillis()));</span>

<span class="fc" id="L234">    postOrderTraversal(root, new Callback() {</span>
      public boolean process(Node node) {

<span class="fc bfc" id="L237" title="All 4 branches covered.">        while (iterator.hasNext() &amp;&amp; iterator.peek() &lt;= node.getUpperBound()) {</span>
<span class="fc" id="L238">          double bucketCount = sum.get() - lastSum.get();</span>

<span class="fc" id="L240">          Bucket bucket = new Bucket(</span>
              bucketCount / normalizationFactor, bucketWeightedSum.get() / bucketCount);

<span class="fc" id="L243">          builder.add(bucket);</span>
<span class="fc" id="L244">          lastSum.set(sum.get());</span>
<span class="fc" id="L245">          bucketWeightedSum.set(0);</span>
<span class="fc" id="L246">          iterator.next();</span>
<span class="fc" id="L247">        }</span>

<span class="fc" id="L249">        bucketWeightedSum.addAndGet(node.getMiddle() * node.weightedCount);</span>
<span class="fc" id="L250">        sum.addAndGet(node.weightedCount);</span>
<span class="fc" id="L251">        return iterator.hasNext();</span>
      }
    });

<span class="fc bfc" id="L255" title="All 2 branches covered.">    while (iterator.hasNext()) {</span>
<span class="fc" id="L256">      double bucketCount = sum.get() - lastSum.get();</span>
<span class="fc" id="L257">      Bucket bucket = new Bucket(</span>
          bucketCount / normalizationFactor, bucketWeightedSum.get() / bucketCount);

<span class="fc" id="L260">      builder.add(bucket);</span>

<span class="fc" id="L262">      iterator.next();</span>
<span class="fc" id="L263">    }</span>

<span class="fc" id="L265">    return builder.build();</span>
  }

  public long getMin() {
<span class="fc" id="L269">    final AtomicLong chosen = new AtomicLong(min);</span>
<span class="fc" id="L270">    postOrderTraversal(root, new Callback() {</span>
      public boolean process(Node node) {
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (node.weightedCount &gt;= ZERO_WEIGHT_THRESHOLD) {</span>
<span class="fc" id="L273">          chosen.set(node.getLowerBound());</span>
<span class="fc" id="L274">          return false;</span>
        }
<span class="nc" id="L276">        return true;</span>
      }
    }, TraversalOrder.FORWARD);

<span class="fc" id="L280">    return Math.max(min, chosen.get());</span>
  }

  public long getMax() {
<span class="fc" id="L284">    final AtomicLong chosen = new AtomicLong(max);</span>
<span class="fc" id="L285">    postOrderTraversal(root, new Callback() {</span>
      public boolean process(Node node) {
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (node.weightedCount &gt;= ZERO_WEIGHT_THRESHOLD) {</span>
<span class="fc" id="L288">          chosen.set(node.getUpperBound());</span>
<span class="fc" id="L289">          return false;</span>
        }
<span class="nc" id="L291">        return true;</span>
      }
    }, TraversalOrder.REVERSE);

<span class="fc" id="L295">    return Math.min(max, chosen.get());</span>
  }

  @VisibleForTesting
  synchronized int getTotalNodeCount() {
<span class="fc" id="L300">    return totalNodeCount;</span>
  }

  @VisibleForTesting
  synchronized int getNonZeroNodeCount() {
<span class="fc" id="L305">    return nonZeroNodeCount;</span>
  }

  @VisibleForTesting
  synchronized int getCompressions() {
<span class="fc" id="L310">    return compressions;</span>
  }

  @VisibleForTesting
  synchronized void compress() {
<span class="fc" id="L315">    ++compressions;</span>

<span class="fc" id="L317">    final int compressionFactor = calculateCompressionFactor();</span>

<span class="fc" id="L319">    postOrderTraversal(root, new Callback() {</span>
      public boolean process(Node node) {
<span class="fc bfc" id="L321" title="All 2 branches covered.">        if (node.isLeaf()) {</span>
<span class="fc" id="L322">          return true;</span>
        }

        // if children's weights are ~0 remove them and shift the weight to their parent

<span class="fc" id="L327">        double leftWeight = 0;</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">        if (node.left != null) {</span>
<span class="fc" id="L329">          leftWeight = node.left.weightedCount;</span>
        }

<span class="fc" id="L332">        double rightWeight = 0;</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (node.right != null) {</span>
<span class="fc" id="L334">          rightWeight = node.right.weightedCount;</span>
        }

<span class="fc bfc" id="L337" title="All 2 branches covered.">        boolean shouldCompress = node.weightedCount + leftWeight + rightWeight &lt;</span>
          weightedCount / compressionFactor;

<span class="fc" id="L340">        double oldNodeWeight = node.weightedCount;</span>
<span class="fc bfc" id="L341" title="All 4 branches covered.">        if (shouldCompress || leftWeight &lt; ZERO_WEIGHT_THRESHOLD) {</span>
<span class="fc" id="L342">          node.left = tryRemove(node.left);</span>

<span class="fc" id="L344">          weightedCount += leftWeight;</span>
<span class="fc" id="L345">          node.weightedCount += leftWeight;</span>
        }

<span class="fc bfc" id="L348" title="All 4 branches covered.">        if (shouldCompress || rightWeight &lt; ZERO_WEIGHT_THRESHOLD) {</span>
<span class="fc" id="L349">          node.right = tryRemove(node.right);</span>

<span class="fc" id="L351">          weightedCount += rightWeight;</span>
<span class="fc" id="L352">          node.weightedCount += rightWeight;</span>
        }

<span class="fc bfc" id="L355" title="All 4 branches covered.">        if (oldNodeWeight &lt; ZERO_WEIGHT_THRESHOLD &amp;&amp; node.weightedCount &gt;= ZERO_WEIGHT_THRESHOLD) {</span>
<span class="fc" id="L356">           ++nonZeroNodeCount;</span>
        }

<span class="fc" id="L359">        return true;</span>
      }
    });

<span class="pc bpc" id="L363" title="1 of 4 branches missed.">    if (root != null &amp;&amp; root.weightedCount &lt; ZERO_WEIGHT_THRESHOLD) {</span>
<span class="fc" id="L364">      root = tryRemove(root);</span>
    }

<span class="fc" id="L367">    maxTotalNodesAfterCompress = Math.max(maxTotalNodesAfterCompress, totalNodeCount);</span>
<span class="fc" id="L368">  }</span>

  private double weight(long timestamp) {
<span class="fc" id="L371">    return Math.exp(alpha * (timestamp - landmarkInSeconds));</span>
  }

  private void rescale(long newLandmarkInSeconds) {
    // rescale the weights based on a new landmark to avoid numerical overflow issues

<span class="fc" id="L377">      final double factor = Math.exp(-alpha * (newLandmarkInSeconds - landmarkInSeconds));</span>

<span class="fc" id="L379">      weightedCount *= factor;</span>

<span class="fc" id="L381">      postOrderTraversal(root, new Callback() {</span>
          public boolean process(Node node) {
<span class="fc" id="L383">            double oldWeight = node.weightedCount;</span>

<span class="fc" id="L385">            node.weightedCount *= factor;</span>

<span class="fc bfc" id="L387" title="All 4 branches covered.">            if (oldWeight &gt;= ZERO_WEIGHT_THRESHOLD &amp;&amp; node.weightedCount &lt; ZERO_WEIGHT_THRESHOLD) {</span>
<span class="fc" id="L388">              --nonZeroNodeCount;</span>
            }

<span class="fc" id="L391">            return true;</span>
          }
      });

<span class="fc" id="L395">      landmarkInSeconds = newLandmarkInSeconds;</span>
<span class="fc" id="L396">  }</span>

  private int calculateCompressionFactor() {
<span class="fc bfc" id="L399" title="All 2 branches covered.">    if (root == null) {</span>
<span class="fc" id="L400">      return 1;</span>
    }

<span class="fc" id="L403">    return Math.max((int) ((root.level + 1) / maxError), 1);</span>
  }

  private void insert(long value, double weight) {
<span class="fc" id="L407">    long lastBranch = 0;</span>
<span class="fc" id="L408">    Node parent = null;</span>
<span class="fc" id="L409">    Node current = root;</span>

    while (true) {
<span class="fc bfc" id="L412" title="All 2 branches covered.">      if (current == null) {</span>
<span class="fc" id="L413">        setChild(parent, lastBranch, createLeaf(value, weight));</span>
<span class="fc" id="L414">        return;</span>
      }
<span class="fc bfc" id="L416" title="All 2 branches covered.">      else if ((value &gt;&gt;&gt; current.level) != (current.value &gt;&gt;&gt; current.level)) {</span>
        // if value and node.value are not in the same branch given node's level,
        // insert a parent above them at the point at which branches diverge
<span class="fc" id="L419">        setChild(parent, lastBranch, makeSiblings(current, createLeaf(value, weight)));</span>
<span class="fc" id="L420">        return;</span>
      }
<span class="pc bpc" id="L422" title="1 of 4 branches missed.">      else if (current.level == 0 &amp;&amp; current.value == value) {</span>
        // found the node

<span class="fc" id="L425">        double oldWeight = current.weightedCount;</span>

<span class="fc" id="L427">        current.weightedCount += weight;</span>

<span class="pc bpc" id="L429" title="2 of 4 branches missed.">        if (current.weightedCount &gt;= ZERO_WEIGHT_THRESHOLD &amp;&amp; oldWeight &lt; ZERO_WEIGHT_THRESHOLD) {</span>
<span class="nc" id="L430">          ++nonZeroNodeCount;</span>
        }

<span class="fc" id="L433">        return;</span>
      }

      // we're on the correct branch of the tree and we haven't reached a leaf, so keep going down
<span class="fc" id="L437">      long branch = value &amp; current.getBranchMask();</span>

<span class="fc" id="L439">      parent = current;</span>
<span class="fc" id="L440">      lastBranch = branch;</span>

<span class="fc bfc" id="L442" title="All 2 branches covered.">      if (branch == 0) {</span>
<span class="fc" id="L443">        current = current.left;</span>
      }
      else {
<span class="fc" id="L446">        current = current.right;</span>
      }
<span class="fc" id="L448">    }</span>
  }

  private void setChild(Node parent, long branch, Node child) {
<span class="fc bfc" id="L452" title="All 2 branches covered.">    if (parent == null) {</span>
<span class="fc" id="L453">      root = child;</span>
    }
<span class="fc bfc" id="L455" title="All 2 branches covered.">    else if (branch == 0) {</span>
<span class="fc" id="L456">      parent.left = child;</span>
    }
    else {
<span class="fc" id="L459">      parent.right = child;</span>
    }
<span class="fc" id="L461">  }</span>

  private Node makeSiblings(Node node, Node sibling) {
<span class="fc" id="L464">    int parentLevel = MAX_BITS - Long.numberOfLeadingZeros(node.value ^ sibling.value);</span>

<span class="fc" id="L466">    Node parent = new Node(node.value, parentLevel, 0);</span>

    // the branch is given by the bit at the level one below parent
<span class="fc" id="L469">    long branch = sibling.value &amp; parent.getBranchMask();</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">    if (branch == 0) {</span>
<span class="fc" id="L471">      parent.left = sibling;</span>
<span class="fc" id="L472">      parent.right = node;</span>
    }
    else {
<span class="fc" id="L475">      parent.left = node;</span>
<span class="fc" id="L476">      parent.right = sibling;</span>
    }

<span class="fc" id="L479">    ++totalNodeCount;</span>
<span class="fc" id="L480">    maxTotalNodeCount = Math.max(maxTotalNodeCount, totalNodeCount);</span>

<span class="fc" id="L482">    return parent;</span>
  }

  private Node createLeaf(long value, double weight) {
<span class="fc" id="L486">    ++totalNodeCount;</span>
<span class="fc" id="L487">    maxTotalNodeCount = Math.max(maxTotalNodeCount, totalNodeCount);</span>
<span class="fc" id="L488">    ++nonZeroNodeCount;</span>
<span class="fc" id="L489">    return new Node(value, 0, weight);</span>
  }

  /**
   * Remove the node if possible or set its count to 0 if it has children and
   * it needs to be kept around
   */
  private Node tryRemove(Node node) {
<span class="fc bfc" id="L497" title="All 2 branches covered.">    if (node == null) {</span>
<span class="fc" id="L498">      return null;</span>
    }

<span class="fc bfc" id="L501" title="All 2 branches covered.">    if (node.weightedCount &gt;= ZERO_WEIGHT_THRESHOLD) {</span>
<span class="fc" id="L502">      --nonZeroNodeCount;</span>
    }

<span class="fc" id="L505">    weightedCount -= node.weightedCount;</span>

<span class="fc" id="L507">    Node result = null;</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">    if (node.isLeaf()) {</span>
<span class="fc" id="L509">      --totalNodeCount;</span>
    }
<span class="fc bfc" id="L511" title="All 2 branches covered.">    else if (node.hasSingleChild()) {</span>
<span class="fc" id="L512">      result = node.getSingleChild();</span>
<span class="fc" id="L513">      --totalNodeCount;</span>
    }
    else {
<span class="fc" id="L516">      node.weightedCount = 0;</span>
<span class="fc" id="L517">      result = node;</span>
    }

<span class="fc" id="L520">    return result;</span>
  }

  private boolean postOrderTraversal(Node node, Callback callback) {
<span class="fc" id="L524">    return postOrderTraversal(node, callback, TraversalOrder.FORWARD);</span>
  }

    // returns true if traversal should continue
  private boolean postOrderTraversal(Node node, Callback callback, TraversalOrder order) {
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">    if (node == null) {</span>
<span class="nc" id="L530">      return false;</span>
    }

    Node first;
    Node second;

<span class="fc bfc" id="L536" title="All 2 branches covered.">    if (order == TraversalOrder.FORWARD) {</span>
<span class="fc" id="L537">      first = node.left;</span>
<span class="fc" id="L538">      second = node.right;</span>
    }
    else {
<span class="fc" id="L541">      first = node.right;</span>
<span class="fc" id="L542">      second = node.left;</span>
    }

<span class="fc bfc" id="L545" title="All 4 branches covered.">    if (first != null &amp;&amp; !postOrderTraversal(first, callback, order)) {</span>
<span class="fc" id="L546">      return false;</span>
    }

<span class="fc bfc" id="L549" title="All 4 branches covered.">    if (second != null &amp;&amp; !postOrderTraversal(second, callback, order)) {</span>
<span class="fc" id="L550">      return false;</span>
    }

<span class="fc" id="L553">    return callback.process(node);</span>
  }

  /**
   * Computes the maximum error of the current digest
   */
  public synchronized double getConfidenceFactor() {
<span class="fc" id="L560">    return computeMaxPathWeight(root) * 1.0 / weightedCount;</span>
  }

  /**
   * Computes the max &quot;weight&quot; of any path starting at node and ending at a leaf in the
   * hypothetical complete tree. The weight is the sum of counts in the ancestors of a given node
   */
  private double computeMaxPathWeight(Node node) {
<span class="fc bfc" id="L568" title="All 4 branches covered.">    if (node == null || node.level == 0) {</span>
<span class="fc" id="L569">      return 0;</span>
    }

<span class="fc" id="L572">    double leftMaxWeight = computeMaxPathWeight(node.left);</span>
<span class="fc" id="L573">    double rightMaxWeight = computeMaxPathWeight(node.right);</span>

<span class="fc" id="L575">    return Math.max(leftMaxWeight, rightMaxWeight) + node.weightedCount;</span>
  }

  @VisibleForTesting
  synchronized void validate() {
<span class="fc" id="L580">    final AtomicDouble sumOfWeights = new AtomicDouble();</span>
<span class="fc" id="L581">    final AtomicInteger actualNodeCount = new AtomicInteger();</span>
<span class="fc" id="L582">    final AtomicInteger actualNonZeroNodeCount = new AtomicInteger();</span>

<span class="pc bpc" id="L584" title="1 of 2 branches missed.">    if (root != null) {</span>
<span class="fc" id="L585">      validateStructure(root);</span>

<span class="fc" id="L587">      postOrderTraversal(root, new Callback() {</span>
        @Override
        public boolean process(Node node) {
<span class="fc" id="L590">          sumOfWeights.addAndGet(node.weightedCount);</span>
<span class="fc" id="L591">          actualNodeCount.incrementAndGet();</span>

<span class="fc bfc" id="L593" title="All 2 branches covered.">          if (node.weightedCount &gt; ZERO_WEIGHT_THRESHOLD) {</span>
<span class="fc" id="L594">            actualNonZeroNodeCount.incrementAndGet();</span>
          }

<span class="fc" id="L597">          return true;</span>
        }
      });
    }

<span class="pc bpc" id="L602" title="1 of 2 branches missed.">    checkState(Math.abs(sumOfWeights.get() - weightedCount) &lt; ZERO_WEIGHT_THRESHOLD,</span>
               &quot;Computed weight (%s) doesn't match summary (%s)&quot;, sumOfWeights.get(),
               weightedCount);

<span class="pc bpc" id="L606" title="1 of 2 branches missed.">    checkState(actualNodeCount.get() == totalNodeCount,</span>
      &quot;Actual node count (%s) doesn't match summary (%s)&quot;,
      actualNodeCount.get(), totalNodeCount);

<span class="pc bpc" id="L610" title="1 of 2 branches missed.">    checkState(actualNonZeroNodeCount.get() == nonZeroNodeCount,</span>
      &quot;Actual non-zero node count (%s) doesn't match summary (%s)&quot;,
      actualNonZeroNodeCount.get(), nonZeroNodeCount);
<span class="fc" id="L613">  }</span>

  private void validateStructure(Node node) {
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">    checkState(node.level &gt;= 0);</span>

<span class="fc bfc" id="L618" title="All 2 branches covered.">    if (node.left != null) {</span>
<span class="fc" id="L619">      validateBranchStructure(node, node.left, node.right, true);</span>
<span class="fc" id="L620">      validateStructure(node.left);</span>
    }

<span class="fc bfc" id="L623" title="All 2 branches covered.">    if (node.right != null) {</span>
<span class="fc" id="L624">      validateBranchStructure(node, node.right, node.left, false);</span>
<span class="fc" id="L625">      validateStructure(node.right);</span>
    }
<span class="fc" id="L627">  }</span>

  private void validateBranchStructure(Node parent, Node child, Node otherChild, boolean isLeft) {
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">    checkState(child.level &lt; parent.level,</span>
               &quot;Child level (%s) should be smaller than parent level (%s)&quot;, child.level,
               parent.level);

<span class="fc" id="L634">    long branch = child.value &amp; (1L &lt;&lt; (parent.level - 1));</span>
<span class="pc bpc" id="L635" title="3 of 8 branches missed.">    checkState(branch == 0 &amp;&amp; isLeft || branch != 0 &amp;&amp; !isLeft,</span>
               &quot;Value of child node is inconsistent with its branch&quot;);

<span class="pc bpc" id="L638" title="1 of 6 branches missed.">    Preconditions.checkState(parent.weightedCount &gt;= ZERO_WEIGHT_THRESHOLD ||</span>
                               child.weightedCount &gt;= ZERO_WEIGHT_THRESHOLD || otherChild != null,
                             &quot;Found a linear chain of zero-weight nodes&quot;);
<span class="fc" id="L641">  }</span>

  public static class Bucket {
    private double count;
    private double mean;

<span class="fc" id="L647">    public Bucket(double count, double mean) {</span>
<span class="fc" id="L648">      this.count = count;</span>
<span class="fc" id="L649">      this.mean = mean;</span>
<span class="fc" id="L650">    }</span>

    public double getCount() {
<span class="fc" id="L653">      return count;</span>
    }

    public double getMean() {
<span class="fc" id="L657">      return mean;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">      if (this == o) {</span>
<span class="nc" id="L663">        return true;</span>
      }
<span class="pc bpc" id="L665" title="2 of 4 branches missed.">      if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L666">        return false;</span>
      }

<span class="fc" id="L669">      final Bucket bucket = (Bucket) o;</span>

<span class="pc bpc" id="L671" title="1 of 2 branches missed.">      if (Double.compare(bucket.count, count) != 0) {</span>
<span class="nc" id="L672">        return false;</span>
      }
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">      if (Double.compare(bucket.mean, mean) != 0) {</span>
<span class="nc" id="L675">        return false;</span>
      }

<span class="fc" id="L678">      return true;</span>
    }

    @Override
    public int hashCode() {
      int result;
      long temp;
<span class="nc bnc" id="L685" title="All 2 branches missed.">      temp = count != +0.0d ? Double.doubleToLongBits(count) : 0L;</span>
<span class="nc" id="L686">      result = (int) (temp ^ (temp &gt;&gt;&gt; 32));</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">      temp = mean != +0.0d ? Double.doubleToLongBits(mean) : 0L;</span>
<span class="nc" id="L688">      result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</span>
<span class="nc" id="L689">      return result;</span>
    }

    public String toString() {
<span class="fc" id="L693">      return String.format(&quot;[count: %f, mean: %f]&quot;, count, mean);</span>
    }
  }

  private static class Node {
    private double weightedCount;
    private int level;
    private long value;
    private Node left;
    private Node right;

<span class="fc" id="L704">    private Node(long value, int level, double weightedCount) {</span>
<span class="fc" id="L705">      this.value = value;</span>
<span class="fc" id="L706">      this.level = level;</span>
<span class="fc" id="L707">      this.weightedCount = weightedCount;</span>
<span class="fc" id="L708">    }</span>

    public boolean isLeaf() {
<span class="fc bfc" id="L711" title="All 4 branches covered.">      return left == null &amp;&amp; right == null;</span>
    }

    public boolean hasSingleChild() {
<span class="pc bpc" id="L715" title="2 of 8 branches missed.">      return left == null &amp;&amp; right != null || left != null &amp;&amp; right == null;</span>
    }

    public Node getSingleChild() {
<span class="fc" id="L719">      checkState(hasSingleChild(), &quot;Node does not have a single child&quot;);</span>
<span class="fc" id="L720">      return Objects.firstNonNull(left, right);</span>
    }

    public long getUpperBound() {
      // set all lsb below level to 1 (we're looking for the highest value of the range covered
      // by this node)
<span class="fc" id="L726">      long mask = (1L &lt;&lt; level) - 1;</span>
<span class="fc" id="L727">      return value | mask;</span>
    }

    public long getBranchMask() {
<span class="fc" id="L731">      return (1L &lt;&lt; (level - 1));</span>
    }

    public long getLowerBound() {
      // set all lsb below level to 0 (we're looking for the lowes value of the range covered
      // by this node)
<span class="fc" id="L737">      long mask = (0x7FFFFFFFFFFFFFFFL &lt;&lt; level);</span>
<span class="fc" id="L738">      return value &amp; mask;</span>
    }

    public long getMiddle() {
<span class="fc" id="L742">      return getLowerBound() + (getUpperBound() - getLowerBound()) / 2;</span>
    }

    public String toString() {
<span class="nc bnc" id="L746" title="All 4 branches missed.">      return format(&quot;%s (level = %d, count = %s, left = %s, right = %s)&quot;, value, level,</span>
                    weightedCount, left != null, right != null);
    }
  }

  private static interface Callback {
    /**
     * @param node the node to process
     * @return true if processing should continue
     */
    boolean process(Node node);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.0.201210061924</span></div></body></html>